# Розділ 5: Архітектура Системи

Цей розділ описує загальну архітектуру системи, починаючи з MVP-версії, яка базується на сучасних керованих сервісах, і закінчуючи цільовою архітектурою для майбутнього масштабування.

## 5.1. Огляд Архітектури MVP

Архітектура MVP — це повноцінне full-stack рішення на TypeScript, що використовує Next.js 16 та Supabase, розгорнуте на керованих сервісах Vercel та Supabase Cloud. Це, по суті, дворівнева архітектура (Клієнт та Хмара) з тісною інтеграцією фронтенду та бекенду.

```
┌─────────────────────────────────────────────────────────┐
│                   Клієнт (Браузер/PWA)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │   Next.js    │  │  React RSC   │  │ Service      │   │
│  │  App Router  │  │ (Компоненти) │  │ Worker       │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │   Zustand    │  │   Context    │  │  IndexedDB   │   │
│  │Бізнес-логіка │  │(UI/Автентиф.)│  │  (Офлайн)    │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │ HTTPS
                          ▼
┌─────────────────────────────────────────────────────────┐
│               Vercel Edge Network (CDN)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  Статичні    │  │  Edge        │  │  Edge        │   │
│  │  ресурси     │  │  Functions   │  │  Config      │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│         Next.js Сервер (Vercel Serverless)              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │   Серверні   │  │   Server     │  │     API      │   │
│  │  Компоненти  │  │   Actions    │  │    Routes    │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  Платформа Supabase                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │  Postgres    │  │   Storage    │  │  Realtime    │   │
│  │  (База даних)│  │   (S3-like)  │  │  (WebSocket) │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │     Auth     │  │    Edge      │  │   Vectors    │   │
│  │  (GoTrue)    │  │  Functions   │  │  (pgvector)  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                Зовнішні Інтеграції                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ Нова Пошта   │  │     SMS      │  │   Email      │   │
│  │     API      │  │  Провайдер   │  │   SMTP       │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 5.1.1. Вхідна точка: Edge Proxy (`src/proxy.ts`)

Ключовим елементом архітектури, що працює на рівні **Vercel Edge Network**, є файл `src/proxy.ts`. Це Next.js Proxy (раніше відомий як Middleware), який виконується для кожного вхідного запиту ще до того, як він досягне основного серверного коду.

**Основні завдання `proxy.ts`:**

1.  **Керування сесіями:** Перевіряє автентифікаційні cookies та оновлює їх, забезпечуючи актуальність сесії користувача.
2.  **Захист маршрутів:** Реалізує логіку доступу. Якщо неавтентифікований користувач намагається зайти на захищений маршрут (наприклад, `/dashboard`), proxy перенаправляє його на сторінку входу.
3.  **Перенаправлення автентифікованих користувачів:** Якщо користувач, що вже увійшов, намагається відвідати сторінку входу, proxy автоматично направить його до кабінету.

Список захищених маршрутів легко конфігурується через масив `protectedRoutes` у файлі, що дозволяє гнучко керувати доступом.

```typescript
// src/proxy.ts
const protectedRoutes = ['/dashboard', '/settings'];
```

Такий підхід дозволяє централізовано керувати безпекою та доступом до всього застосунку.


## 5.2. Патерни Потоків Даних

Система використовує гібридний підхід до отримання та зміни даних, комбінуючи найкращі практики сучасного вебу.

#### 5.2.1. Рендеринг на Сервері (SSR)

Використовується для початкового завантаження сторінок, що робить їх дружніми до SEO та забезпечує швидкий показ контенту (FCP).

```typescript
// app/dashboard/page.tsx
import { createServerClient } from '@/lib/supabase/server';
import { DashboardView } from './_components/dashboard-view';

// Компонент рендериться на сервері
export default async function DashboardPage() {
  const supabase = createServerClient(); // Створюємо серверний клієнт Supabase
  const { data: deals } = await supabase
    .from('deals')
    .select('*')
    .limit(10);
  
  // Передаємо дані в клієнтський компонент для гідратації
  return <DashboardView deals={deals} />;
}
```

#### 5.2.2. Запити на Клієнті (CSR)

Використовуються для динамічних частин інтерфейсу, де дані часто оновлюються без перезавантаження сторінки.

```typescript
// hooks/useDeals.ts
import { createBrowserClient } from '@/lib/supabase/client';
import { useState, useEffect } from 'react';

// Хук для отримання даних на клієнті
export function useDeals() {
  const [deals, setDeals] = useState([]);
  
  useEffect(() => {
    const supabase = createBrowserClient();
    supabase.from('deals').select('*').then(({ data }) => setDeals(data || []));
  }, []);
  
  return deals;
}
```

#### 5.2.3. Серверні дії (Server Actions)

Це основний механізм для зміни даних (створення, оновлення, видалення). Він дозволяє викликати серверний код безпосередньо з клієнтських компонентів. Такий підхід значно спрощує архітектуру, оскільки **усуває необхідність створювати окремий шар API (REST або GraphQL)** для внутрішніх потреб додатку. Вся логіка надійно виконується на сервері, а фреймворк Next.js автоматично обробляє передачу даних, їх валідацію та оновлення кешу.

```typescript
// app/actions/deals.ts
'use server'; // Директива, що робить цей модуль серверним

import { revalidatePath } from 'next/cache';

export async function createDeal(formData: FormData) {
  const supabase = createServerClient();
  const { data, error } = await supabase
    .from('deals')
    .insert({
      name: formData.get('name'),
      amount: formData.get('amount')
    });
  
  // Очищуємо кеш для сторінки, щоб відобразити нові дані
  revalidatePath('/dashboard');
  return { data, error };
}

// Використання на клієнті
<form action={createDeal}>
  <input name="name" />
  <button type="submit">Створити</button>
</form>
```

#### 5.2.4. Realtime-підписки

Для миттєвого оновлення даних між різними клієнтами (наприклад, для спільної роботи) використовуються веб-сокети через сервіс Supabase Realtime.

```typescript
useEffect(() => {
  const channel = supabase
    .channel('deals-changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'deals' },
      (payload) => {
        // Оновлюємо локальний стан при змінах в БД
        console.log('New change received!', payload);
      }
    )
    .subscribe();
  
  return () => channel.unsubscribe();
}, []);
```

## 5.3. Архітектура Офлайн-роботи (Offline-First)

Це ключова вимога, що забезпечується за допомогою Service Worker та IndexedDB.

*   **Рівні зберігання:**
    1.  **Стан в пам'яті (RAM):** Zustand + React Context для миттєвого доступу.
    2.  **Кеш на клієнті (IndexedDB):** Зберігає дані сутностей (клієнти, угоди) та чергу операцій, що очікують синхронізації.
    3.  **База даних на сервері (Postgres):** Основне джерело правди.

*   **Стратегія синхронізації:**
    *   **Оптимістичний UI:** Зміни миттєво відображаються в інтерфейсі та зберігаються локально.
    *   **Черга синхронізації:** Усі операції запису, зроблені в офлайні, додаються до черги в IndexedDB.
    *   **Процес синхронізації:** Черга обробляється автоматично при відновленні інтернет-з'єднання (через Background Sync API) або при наступному запуску додатку.
    *   **Вирішення конфліктів:** За замовчуванням застосовується стратегія "Last Write Wins" (останній запис перемагає). Для критичних даних можливе ручне вирішення конфлікту.

## 5.4. Архітектура Коду: Feature-Sliced Design та Сервісний Шар

Для забезпечення довгострокової підтримуваності та масштабованості кодової бази застосовується гібридний підхід, що поєднує методологію **Feature-Sliced Design (FSD)** з класичним патерном **"Сервіс-Репозиторій"**.

### 5.4.1. Feature-Sliced Design (FSD)
FSD є основою для групування коду за бізнес-функціями. Це дозволяє ізолювати функціонал, спростити навігацію та паралельну розробку.

**Основні елементи структури FSD:**
*   **Слайси (Slices):** Код групується за функціональними модулями (`customers`, `orders`, `auth`).
*   **Шари (Layers):** В межах кожного слайсу код розділено на логічні шари (`ui`, `model`, `api`).

### 5.4.2. Доповнення FSD: Сервісний Шар та Репозиторії

Для більш чіткого розділення відповідальностей, особливо в `shared` ядрі системи, ми доповнюємо FSD класичним тришаровим підходом до бізнес-логіки.

```
┌──────────────────┐
│   Server Action  │  <-- Вхідна точка (UI, API)
│  (або API Route) │
└──────────────────┘
         │ (викликає)
         ▼
┌──────────────────┐
│    Сервіс        │  <-- Оркестрація та Бізнес-логіка
│ (billing.service)│  (напр., "як оновити підписку?")
└──────────────────┘
         │ (використовує)
         ▼
┌──────────────────┐
│    Репозиторій   │  <-- Прямий доступ до даних
│(quota.repository)│ (напр., "дай/оновіть запис з таблиці quotas")
└──────────────────┘
         │ (робить запит до)
         ▼
┌──────────────────┐
│    База Даних    │
│    (Supabase)    │
└──────────────────┘
```

**Опис шарів:**

1.  **Repository Layer (`src/shared/lib/repositories/`)**
    *   **Відповідальність:** Єдиний шар, який безпосередньо взаємодіє з базою даних (через клієнт Supabase).
    *   **Завдання:** Виконувати "сирі" CRUD-операції (`select`, `insert`, `update`, `delete`). Не містить жодної бізнес-логіки. Приймає прості аргументи (напр., `workspaceId`) і повертає дані з БД.
    *   **Приклад:** `quota.repository.ts` містить функцію `getQuotasByWorkspaceId`, яка просто робить `select` з таблиці `workspace_quotas`.

2.  **Service Layer (`src/shared/lib/services/`)**
    *   **Відповідальність:** Оркестрація та реалізація всієї бізнес-логіки.
    *   **Завдання:** Використовує один або декілька репозиторіїв для отримання та збереження даних, реалізує складні сценарії та приймає рішення.
    *   **Приклад:** `billing.service.ts` містить функцію `upgradeSubscription`, яка:
        1.  Викликає `subscriptionRepository.update()` для зміни тарифу.
        2.  Викликає `quotaRepository.updateQuotas()` для встановлення нових лімітів.
        3.  В майбутньому може викликати `EmailService` для відправки повідомлення.

**Переваги такого підходу:**
*   **Чітке розділення відповідальностей (Separation of Concerns):** Бізнес-логіка не "розмазана" по Server Actions, а централізована в сервісах, що робить її перевикористовуваною та легкою для тестування.
*   **Тестованість:** Репозиторії можна легко "мокати" (mock) при тестуванні сервісів, перевіряючи лише бізнес-логіку.
*   **Гнучкість:** Якщо ми вирішимо змінити ORM або джерело даних, зміни потрібно буде внести лише в шар репозиторіїв, не зачіпаючи бізнес-логіку в сервісах.

## 5.5. Обмеження безкоштовних тарифів та їх обхід (MVP)

Ключовим завданням MVP є запуск з мінімальними витратами, що вимагає креативних рішень для обходу лімітів безкоштовних тарифів.

*   **Supabase (500 MB DB, 1 GB Storage):**
    *   **Рішення:** Великі файли (зображення, документи) зберігаються не в базі даних, а в Supabase Storage (S3-сумісне сховище). Зображення перед завантаженням стискаються на клієнті. Для старих, неактуальних даних може бути застосована політика архівування.

*   **Vercel (обмеження часу виконання функцій):**
    *   **Рішення:** Важкі або довготривалі операції виносяться в Supabase Edge Functions, які мають більший ліміт часу виконання (~150с проти ~10с у Vercel на безкоштовному тарифі).

*   **Замість Redis (кеш, черги):**
    *   **Рішення:** Для простого кешування використовуються можливості Vercel Edge Network. Для реалізації черг використовується розширення **`pgmq`** в PostgreSQL, яке дозволяє створювати надійні черги повідомлень безпосередньо в базі даних.

*   **Замість RabbitMQ (фонові задачі):**
    *   **Рішення:** Ми емулюємо повноцінний обробник фонових завдань, комбінуючи інструменти Supabase. За допомогою розширення **`pg_cron`** (планувальник завдань для Postgres) ми періодично (наприклад, щохвилини) викликаємо **Supabase Edge Function**. Ця функція, у свою чергу, перевіряє чергу завдань (створену за допомогою `pgmq` або просто таблицю `jobs`) і обробляє їх. Це дозволяє реалізувати відкладені задачі, розсилки, періодичні перевірки статусів тощо, не вдаючись до платних сторонніх сервісів.

## 5.6. Цільова Архітектура (масштабування на VPS)

При зростанні клієнтської бази та перевищенні лімітів безкоштовних тарифів планується міграція на власні або орендовані сервери (VPS/хмара), щоб забезпечити більшу продуктивність, гнучкість та контроль над витратами.

**Стек технологій на VPS:**
```
┌──────────────────────────────────────┐
│         Load Balancer (nginx)        │
└──────────────────────────────────────┘
                  │
    ┌─────────────┴─────────────┐
    ▼                           ▼
┌─────────┐                 ┌─────────┐
│ Next.js │                 │ Next.js │
│  Node   │                 │  Node   │
└─────────┘                 └─────────┘
    │                           │
    └─────────────┬─────────────┘
                  ▼
    ┌─────────────────────────────┐
    │         Redis               │
    │  - Сесії                    │
    │  - Кеш                      │
    │  - Обмеження запитів        │
    └─────────────────────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │      PostgreSQL             │
    │  - Master (читання/запис)   │
    │  - Replica (тільки читання) │
    └─────────────────────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │      RabbitMQ/NATS          │
    │  - Фонові задачі            │
    │  - Вебхуки                  │
    │  - Черги Email              │
    └─────────────────────────────┘
```

**Ключові зміни та компоненти:**
*   **Веб-сервер:** Додаток Next.js запускається на Node.js сервері (у Docker-контейнері), що знімає обмеження безсерверних функцій. За балансувальником навантаження (Nginx) може працювати кілька екземплярів додатку для горизонтального масштабування.
*   **База даних:** Міграція Postgres з Supabase на власний сервер або керований сервіс (наприклад, AWS RDS). Це дозволить налаштувати реплікацію (read replicas) для зняття навантаження з основного сервера.
*   **Автентифікація:** Заміна Supabase Auth на самостійно розміщений **GoTrue** (відкритий компонент Supabase) або інший сервіс, щоб зберегти контроль над користувацькими даними.
*   **Redis:** Впровадження Redis для ефективного кешування запитів до бази даних, керування сесіями та як швидка шина для обміну повідомленнями (Pub/Sub).
*   **RabbitMQ/NATS:** Впровадження повноцінного брокера повідомлень для надійної обробки фонових завдань (відправка email, генерація звітів, обробка вебхуків). Це розвантажить основний додаток і підвищить відгукливість інтерфейсу.
*   **Моніторинг:** Налаштування стеку Prometheus/Grafana або використання комерційних сервісів для моніторингу та логування всієї інфраструктури.

**Шлях міграції (Migration Path):**
1.  **Експорт даних** з Supabase (`pg_dump`).
2.  **Налаштування VPS** та розгортання всієї інфраструктури за допомогою Docker Compose.
3.  **Імпорт даних** у нову базу даних PostgreSQL.
4.  **Оновлення конфігурації** додатку (змінні середовища, підключення до БД).
5.  **Переключення DNS** на новий сервер. Для мінімізації простою можна використовувати стратегію Blue-Green Deployment.

Ця архітектура дозволить гнучко масштабувати кожен компонент системи незалежно, забезпечуючи високу продуктивність та надійність при зростанні навантаження.
