# Розділ 5: Архітектура Системи

Цей розділ описує загальну архітектуру системи, починаючи з MVP-версії, яка базується на сучасних керованих сервісах, і закінчуючи цільовою архітектурою для майбутнього масштабування.

## 5.1. Огляд Архітектури MVP

Архітектура MVP — це повноцінне full-stack рішення на TypeScript, що використовує Next.js 16 та Supabase, розгорнуте на керованих сервісах Vercel та Supabase Cloud. Це, по суті, дворівнева архітектура (Клієнт та Хмара) з тісною інтеграцією фронтенду та бекенду.

```
┌─────────────────────────────────────────────────────────┐
│                   Клієнт (Браузер/PWA)                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Next.js    │  │  React RSC   │  │ Service      │  │
│  │  App Router  │  │ (Компоненти) │  │ Worker       │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Zustand    │  │   Context    │  │  IndexedDB   │  │
│  │ (Бізнес-логіка)│  │ (UI/Автентиф.)│  │  (Офлайн)    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │ HTTPS
                          ▼
┌─────────────────────────────────────────────────────────┐
│               Vercel Edge Network (CDN)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  Статичні    │  │  Edge        │  │  Edge        │  │
│  │  ресурси     │  │  Functions   │  │  Config      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│         Next.js Сервер (Vercel Serverless)              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Серверні   │  │   Server     │  │     API      │  │
│  │  Компоненти  │  │   Actions    │  │    Routes    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  Платформа Supabase                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  Postgres    │  │   Storage    │  │  Realtime    │  │
│  │  (База даних)│  │   (S3-like)  │  │  (WebSocket) │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │     Auth     │  │    Edge      │  │   Vectors    │  │
│  │  (GoTrue)    │  │  Functions   │  │  (pgvector)  │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                Зовнішні Інтеграції                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Нова Пошта  │  │   SMS          │  │   Email      │  │
│  │     API      │  │  Провайдер   │  │   SMTP       │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 5.1.1. Вхідна точка: Edge Proxy (`src/proxy.ts`)

Ключовим елементом архітектури, що працює на рівні **Vercel Edge Network**, є файл `src/proxy.ts`. Це Next.js Proxy (раніше відомий як Middleware), який виконується для кожного вхідного запиту ще до того, як він досягне основного серверного коду.

**Основні завдання `proxy.ts`:**

1.  **Керування сесіями:** Перевіряє автентифікаційні cookies та оновлює їх, забезпечуючи актуальність сесії користувача.
2.  **Захист маршрутів:** Реалізує логіку доступу. Якщо неавтентифікований користувач намагається зайти на захищений маршрут (наприклад, `/dashboard`), proxy перенаправляє його на сторінку входу.
3.  **Перенаправлення автентифікованих користувачів:** Якщо користувач, що вже увійшов, намагається відвідати сторінку входу, proxy автоматично направить його до кабінету.

Список захищених маршрутів легко конфігурується через масив `protectedRoutes` у файлі, що дозволяє гнучко керувати доступом.

```typescript
// src/proxy.ts
const protectedRoutes = ['/dashboard', '/settings'];
```

Такий підхід дозволяє централізовано керувати безпекою та доступом до всього застосунку.


## 5.2. Патерни Потоків Даних

Система використовує гібридний підхід до отримання та зміни даних, комбінуючи найкращі практики сучасного вебу.

#### 5.2.1. Рендеринг на Сервері (SSR)

Використовується для початкового завантаження сторінок, що робить їх дружніми до SEO та забезпечує швидкий показ контенту (FCP).

```typescript
// app/dashboard/page.tsx
import { createServerClient } from '@/lib/supabase/server';
import { DashboardView } from './_components/dashboard-view';

// Компонент рендериться на сервері
export default async function DashboardPage() {
  const supabase = createServerClient(); // Створюємо серверний клієнт Supabase
  const { data: deals } = await supabase
    .from('deals')
    .select('*')
    .limit(10);
  
  // Передаємо дані в клієнтський компонент для гідратації
  return <DashboardView deals={deals} />;
}
```

#### 5.2.2. Запити на Клієнті (CSR)

Використовуються для динамічних частин інтерфейсу, де дані часто оновлюються без перезавантаження сторінки.

```typescript
// hooks/useDeals.ts
import { createBrowserClient } from '@/lib/supabase/client';
import { useState, useEffect } from 'react';

// Хук для отримання даних на клієнті
export function useDeals() {
  const [deals, setDeals] = useState([]);
  
  useEffect(() => {
    const supabase = createBrowserClient();
    supabase.from('deals').select('*').then(({ data }) => setDeals(data || []));
  }, []);
  
  return deals;
}
```

#### 5.2.3. Серверні дії (Server Actions)

Це основний механізм для зміни даних (створення, оновлення, видалення). Він дозволяє викликати серверний код безпосередньо з клієнтських компонентів. Такий підхід значно спрощує архітектуру, оскільки **усуває необхідність створювати окремий шар API (REST або GraphQL)** для внутрішніх потреб додатку. Вся логіка надійно виконується на сервері, а фреймворк Next.js автоматично обробляє передачу даних, їх валідацію та оновлення кешу.

```typescript
// app/actions/deals.ts
'use server'; // Директива, що робить цей модуль серверним

import { revalidatePath } from 'next/cache';

export async function createDeal(formData: FormData) {
  const supabase = createServerClient();
  const { data, error } = await supabase
    .from('deals')
    .insert({
      name: formData.get('name'),
      amount: formData.get('amount')
    });
  
  // Очищуємо кеш для сторінки, щоб відобразити нові дані
  revalidatePath('/dashboard');
  return { data, error };
}

// Використання на клієнті
<form action={createDeal}>
  <input name="name" />
  <button type="submit">Створити</button>
</form>
```

#### 5.2.4. Realtime-підписки

Для миттєвого оновлення даних між різними клієнтами (наприклад, для спільної роботи) використовуються веб-сокети через сервіс Supabase Realtime.

```typescript
useEffect(() => {
  const channel = supabase
    .channel('deals-changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'deals' },
      (payload) => {
        // Оновлюємо локальний стан при змінах в БД
        console.log('New change received!', payload);
      }
    )
    .subscribe();
  
  return () => channel.unsubscribe();
}, []);
```

## 5.3. Архітектура Офлайн-роботи (Offline-First)

Це ключова вимога, що забезпечується за допомогою Service Worker та IndexedDB.

*   **Рівні зберігання:**
    1.  **Стан в пам'яті (RAM):** Zustand + React Context для миттєвого доступу.
    2.  **Кеш на клієнті (IndexedDB):** Зберігає дані сутностей (клієнти, угоди) та чергу операцій, що очікують синхронізації.
    3.  **База даних на сервері (Postgres):** Основне джерело правди.

*   **Стратегія синхронізації:**
    *   **Оптимістичний UI:** Зміни миттєво відображаються в інтерфейсі та зберігаються локально.
    *   **Черга синхронізації:** Усі операції запису, зроблені в офлайні, додаються до черги в IndexedDB.
    *   **Процес синхронізації:** Черга обробляється автоматично при відновленні інтернет-з'єднання (через Background Sync API) або при наступному запуску додатку.
    *   **Вирішення конфліктів:** За замовчуванням застосовується стратегія "Last Write Wins" (останній запис перемагає). Для критичних даних можливе ручне вирішення конфлікту.

## 5.4. Архітектура Коду (Feature-Sliced Design)

Для забезпечення довгострокової підтримуваності та масштабованості кодової бази застосовується методологія **Feature-Sliced Design (FSD)**. Вона є ключовою для проєкту, оскільки CRM-системи мають тенденцію до зростання функціональності, і без чіткої структури вони швидко перетворюються на складний для підтримки моноліт.

**Чому саме FSD?**
*   **Масштабованість:** Додавання нових функцій (наприклад, "Складський облік" або "Портал постачальників") не зачіпає існуючі, оскільки кожна функція є ізольованим модулем ("слайсом"). Це знижує ризик регресій.
*   **Низька зв'язаність (Low Coupling):** Слайси не залежать від внутрішньої реалізації один одного, а взаємодіють лише через чітко визначений публічний API. Це дозволяє легко замінювати або рефакторити окремі частини системи.
*   **Командна робота:** Розробники можуть працювати над різними "слайсами" паралельно з мінімальними конфліктами при злитті коду.

**Альтернативи, що розглядалися:** Ми розглядали традиційну шарову архітектуру (де код групується за типом: `components/`, `services/`, `hooks/`). Хоча такий підхід є простішим на старті, з часом він призводить до "розмивання" логіки по всьому проєкту, що ускладнює розуміння того, які частини коду відносяться до конкретної функції. FSD, навпаки, забезпечує бізнес-орієнтовану структуру, яка краще масштабується і є більш стійкою до зростання складності.

**Основні елементи структури FSD:**

*   **Слайси (Slices):** Код групується за функціональними модулями (`customers`, `orders`, `auth`). Кожен слайс містить усе необхідне для роботи цієї функції.
*   **Шари (Layers):** В межах кожного слайсу код розділено на логічні шари:
    *   `ui`: Презентаційні React-компоненти (наприклад, `CustomerTable`, `OrderForm`).
    *   `model`: Бізнес-логіка, хуки, функції для роботи з даними та керування станом (`useCustomers`, `orderService`).
    *   `api`: Код для взаємодії з серверним API (`fetchCustomersList`, `createDealAction`).
*   **Публічний API слайсу:** Кожен модуль має чіткий публічний інтерфейс (зазвичай, через `index.ts`), що експортує лише ті компоненти та функції, які призначені для використання ззовні.

**Приклад структури для слайсу `customers`:**
```
src/
└── features/
    └── customers/
        ├── api/
        │   └── customers.api.ts  // Функції для запитів (напр. getCustomers)
        ├── model/
        │   └── customers.store.ts  // Стан та логіка (Zustand store)
        ├── ui/
        │   ├── CustomerTable.tsx   // Компонент таблиці
        │   └── CustomerForm.tsx    // Компонент форми
        └── index.ts                // Публічний API: export { CustomerTable }
```
Такий підхід знижує зв'язаність коду, спрощує навігацію та дозволяє ефективно розвивати продукт, додаючи нові модулі без шкоди для існуючої архітектури.

## 5.5. Обмеження безкоштовних тарифів та їх обхід (MVP)

Ключовим завданням MVP є запуск з мінімальними витратами, що вимагає креативних рішень для обходу лімітів безкоштовних тарифів.

*   **Supabase (500 MB DB, 1 GB Storage):**
    *   **Рішення:** Великі файли (зображення, документи) зберігаються не в базі даних, а в Supabase Storage (S3-сумісне сховище). Зображення перед завантаженням стискаються на клієнті. Для старих, неактуальних даних може бути застосована політика архівування.

*   **Vercel (обмеження часу виконання функцій):**
    *   **Рішення:** Важкі або довготривалі операції виносяться в Supabase Edge Functions, які мають більший ліміт часу виконання (~150с проти ~10с у Vercel на безкоштовному тарифі).

*   **Замість Redis (кеш, черги):**
    *   **Рішення:** Для простого кешування використовуються можливості Vercel Edge Network. Для реалізації черг використовується розширення **`pgmq`** в PostgreSQL, яке дозволяє створювати надійні черги повідомлень безпосередньо в базі даних.

*   **Замість RabbitMQ (фонові задачі):**
    *   **Рішення:** Ми емулюємо повноцінний обробник фонових завдань, комбінуючи інструменти Supabase. За допомогою розширення **`pg_cron`** (планувальник завдань для Postgres) ми періодично (наприклад, щохвилини) викликаємо **Supabase Edge Function**. Ця функція, у свою чергу, перевіряє чергу завдань (створену за допомогою `pgmq` або просто таблицю `jobs`) і обробляє їх. Це дозволяє реалізувати відкладені задачі, розсилки, періодичні перевірки статусів тощо, не вдаючись до платних сторонніх сервісів.

## 5.6. Цільова Архітектура (масштабування на VPS)

При зростанні клієнтської бази та перевищенні лімітів безкоштовних тарифів планується міграція на власні або орендовані сервери (VPS/хмара), щоб забезпечити більшу продуктивність, гнучкість та контроль над витратами.

**Стек технологій на VPS:**
```
┌──────────────────────────────────────┐
│         Load Balancer (nginx)        │
└──────────────────────────────────────┘
                  │
    ┌─────────────┴─────────────┐
    ▼                           ▼
┌─────────┐                 ┌─────────┐
│ Next.js │                 │ Next.js │
│  Node   │                 │  Node   │
└─────────┘                 └─────────┘
    │                           │
    └─────────────┬─────────────┘
                  ▼
    ┌─────────────────────────────┐
    │         Redis               │
    │  - Сесії                    │
    │  - Кеш                      │
    │  - Обмеження запитів        │
    └─────────────────────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │      PostgreSQL             │
    │  - Master (читання/запис)   │
    │  - Replica (тільки читання) │
    └─────────────────────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │      RabbitMQ/NATS          │
    │  - Фонові задачі            │
    │  - Вебхуки                  │
    │  - Черги Email              │
    └─────────────────────────────┘
```

**Ключові зміни та компоненти:**
*   **Веб-сервер:** Додаток Next.js запускається на Node.js сервері (у Docker-контейнері), що знімає обмеження безсерверних функцій. За балансувальником навантаження (Nginx) може працювати кілька екземплярів додатку для горизонтального масштабування.
*   **База даних:** Міграція Postgres з Supabase на власний сервер або керований сервіс (наприклад, AWS RDS). Це дозволить налаштувати реплікацію (read replicas) для зняття навантаження з основного сервера.
*   **Автентифікація:** Заміна Supabase Auth на самостійно розміщений **GoTrue** (відкритий компонент Supabase) або інший сервіс, щоб зберегти контроль над користувацькими даними.
*   **Redis:** Впровадження Redis для ефективного кешування запитів до бази даних, керування сесіями та як швидка шина для обміну повідомленнями (Pub/Sub).
*   **RabbitMQ/NATS:** Впровадження повноцінного брокера повідомлень для надійної обробки фонових завдань (відправка email, генерація звітів, обробка вебхуків). Це розвантажить основний додаток і підвищить відгукливість інтерфейсу.
*   **Моніторинг:** Налаштування стеку Prometheus/Grafana або використання комерційних сервісів для моніторингу та логування всієї інфраструктури.

**Шлях міграції (Migration Path):**
1.  **Експорт даних** з Supabase (`pg_dump`).
2.  **Налаштування VPS** та розгортання всієї інфраструктури за допомогою Docker Compose.
3.  **Імпорт даних** у нову базу даних PostgreSQL.
4.  **Оновлення конфігурації** додатку (змінні середовища, підключення до БД).
5.  **Переключення DNS** на новий сервер. Для мінімізації простою можна використовувати стратегію Blue-Green Deployment.

Ця архітектура дозволить гнучко масштабувати кожен компонент системи незалежно, забезпечуючи високу продуктивність та надійність при зростанні навантаження.
