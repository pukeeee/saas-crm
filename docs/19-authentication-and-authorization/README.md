# Розділ 19: Автентифікація та Авторизація (Вичерпний посібник)

Цей документ надає глибокий технічний огляд оновленої системи автентифікації та авторизації. Він створений як надійне джерело знань для розуміння архітектури та логіки системи в довгостроковій перспективі.

## 1. Загальний огляд та Архітектура

Система побудована на базі **Supabase Auth** з використанням бібліотеки `@supabase/ssr`, що забезпечує тісну та безпечну інтеграцію з Next.js App Router.

**Ключові принципи архітектури:**

-   **Безпека перш за все:** Клієнтський стан завжди ініціалізується даними, підтвердженими на сервері. Це усуває можливість маніпуляцій сесією на клієнті.
-   **Чітке розділення середовищ:** Існує чітке розмежування між клієнтами Supabase для сервера та браузера, що забезпечує правильне та безпечне керування сесіями.
-   **Централізований клієнтський стан:** `AuthProvider` є єдиним джерелом правди для всіх даних, пов'язаних з користувачем на клієнті.
-   **Синхронізація в реальному часі:** Використовується `onAuthStateChange` для миттєвої синхронізації стану між різними вкладками браузера.
-   **Захист на рівні бази даних:** Політики **Row-Level Security (RLS)** в Supabase є фінальним і найважливішим рівнем захисту, що гарантує доступ до даних тільки авторизованим користувачам з відповідними правами.

---

## 2. Потік автентифікації (OAuth з Google)

Процес входу реалізовано як безпечний, багатоетапний потік.

### 2.1. Таблиця потоку автентифікації

| Крок | Актор (Джерело → Ціль)   | Дія     | Примітки         |
| :--- | :----- | :------------------- | :-------- |
| 1    | **Клієнт** → **Сервер**      | Виклик Server Action `signInWithGoogle` | Користувач клікає "Увійти через Google" в `LoginForm.tsx` |
| 2    | **Сервер** → **Supabase**    | Запит `signInWithOAuth`                 | Сервер генерує `callbackUrl` для повернення Google      |
| 3    | **Supabase** → **Сервер**    | Повертає `data.url` для редіректу       | Це унікальна URL для сесії автентифікації Google      |
| 4    | **Сервер** → **Клієнт**      | Відповідь `redirect(data.url)`           | Браузер отримує команду перенаправитись на сайт Google  |
| 5    | **Клієнт** → **Google**      | Автентифікація користувача              | Користувач вводить логін/пароль або обирає акаунт Google |
| 6    | **Google** → **Клієнт**      | Редірект на `/auth/callback?code=...`   | Google повертає браузер на сайт з тимчасовим кодом      |
| 7    | **Клієнт** → **Сервер**      | `GET` запит на `/auth/callback`          | Браузер автоматично переходить за отриманим URL         |
| 8    | **Сервер** → **Supabase**    | Запит `exchangeCodeForSession(code)`    | Сервер обмінює тимчасовий код на постійну сесію       |
| 9    | **Supabase** → **Сервер**    | Повертає дані сесії та користувача      | Supabase встановлює захищені `http-only` cookie          |
| 10   | **Сервер** → **Клієнт**      | Відповідь `redirect('/dashboard')`       | Браузер перенаправляється на захищену сторінку додатку  |

### 2.2. Детальний опис етапів

1.  **Ініціалізація (Клієнт):** Користувач натискає кнопку "Увійти через Google" у компоненті `LoginForm.tsx`.
    -   **Файл:** `src/features/auth/ui/LoginForm.tsx`

2.  **Серверна дія (Сервер):** Викликається Server Action `signInWithGoogle`.
    -   Вона створює серверний клієнт Supabase.
    -   Валідує `redirectUrl` та формує безпечний `callbackUrl` (наприклад, `https://domain.com/auth/callback`).
    -   **Файл:** `src/features/auth/actions/auth.actions.ts`

3.  **Зворотний виклик (Callback):** Після успішної автентифікації в Google, користувач повертається на `/auth/callback`.
    -   Обробник `GET` у `route.ts` отримує `code` від Google.
    -   Він викликає `supabase.auth.exchangeCodeForSession(code)`, щоб безпечно обміняти код на дійсну сесію.
    -   Після успіху користувач перенаправляється на захищену сторінку.
    -   **Файл:** `src/app/auth/callback/route.ts`

---

## 3. Керування сесією та даними

### 3.1. Клієнти Supabase: Сервер vs. Браузер

Бібліотека `@supabase/ssr` вимагає використання різних клієнтів для різних середовищ.

-   **`createBrowserClient()` (Клієнт)**
    -   **Файл:** `src/shared/supabase/client.ts`
    -   **Призначення:** Використовується виключно в клієнтських компонентах (`"use client"`).
    -   **Як працює:** Автоматично взаємодіє з cookie браузера для читання та збереження сесії. Не потребує додаткових налаштувань.

-   **`createServerClient()` (Сервер)**
    -   **Файл:** `src/shared/supabase/server.ts`
    -   **Призначення:** Використовується в серверних компонентах, Server Actions та Route Handlers.
    -   **Як працює:** Потребує явного доступу до cookie, який надається через `cookies()` з `next/headers`. Це дозволяє Supabase безпечно читати та записувати сесію на сервері під час рендеру або виконання дії.

### 3.2. Клієнтський стан: `AuthProvider`

Це ядро клієнтської частини системи.

**Файл:** `src/shared/lib/context/auth-context.tsx`

**Ключові аспекти:**

1.  **Безпечна ініціалізація (`initializeAuth`):**
    -   При першому завантаженні провайдер викликає `await supabase.auth.getUser()`.
    -   **Це найважливіша зміна:** `getUser()` завжди робить запит до сервера Supabase, щоб отримати гарантовано свіжі та автентифіковані дані користувача. Це повністю усуває "гонки станів" та не дозволяє довіряти потенційно застарілим даним з локального сховища.
    -   Після отримання користувача завантажуються пов'язані дані (робочий простір, роль, підписка) через `fetchWorkspace`.

2.  **Підписка на зміни (`onAuthStateChange`):**
    -   Провайдер підписується на події сесії.
    -   **`SIGNED_IN` / `TOKEN_REFRESHED`:** Повторно викликає `getUser()` для отримання свіжих даних та перезавантажує дані робочого простору.
    -   **`SIGNED_OUT`:** Повністю очищує всі дані користувача (`clearUserData`), миттєво оновлюючи UI.

### 3.3. Серверні дії та функції

**Файл:** `src/features/auth/actions/auth.actions.ts`

-   **`signInWithGoogle(formData)`:** Ініціює процес OAuth, як описано вище.
-   **`signOut()`:** Виконує вихід користувача. Викликає `supabase.auth.signOut()` і робить `revalidatePath('/')` для очищення кешу всього додатку, після чого редіректить на головну.
-   **`getSession()`:** Допоміжна серверна дія для отримання поточної сесії на сервері. Може бути використана в серверних компонентах для перевірок.
-   **`refreshSession()`:** Дозволяє примусово оновити сесію.

---

## 4. Доступ до даних та контроль UI

### 4.1. Хуки доступу

Компоненти отримують доступ до даних через спеціалізовані хуки, що абстрагують `useAuthContext`.

**Файл:** `src/shared/hooks/use-auth.ts`

-   **`useAuth()`:** Повертає `{ isAuthenticated: boolean }`. Найпростіший спосіб перевірити, чи увійшов користувач.
-   **`useUser()`:** Повертає об'єкт `user` від Supabase.
-   **`useWorkspace()`:** Надає дані про робочий простір (`workspace`), профіль користувача в ньому (`workspaceUser`) та його роль (`role`).
-   **`useSubscription()` & `useFeatureAccess(featureName)`:**
    -   `useSubscription` дає доступ до даних про підписку (`tier`, `status`).
    -   `useFeatureAccess` перевіряє, чи доступна певна функція (`"automation"`, `"analytics"`) для поточного тарифного плану. Це дозволяє динамічно показувати/ховати функціонал.
-   **`useQuotas()`:** Повертає ліміти та поточне використання ресурсів (контакти, угоди). Дозволяє блокувати створення нових сутностей, якщо ліміт вичерпано.
-   **`usePermission(permission)`:** Перевіряє наявність конкретного дозволу, наприклад, `"delete_contact"`.

### 4.2. Компоненти-охоронці (Permission Guards)

**Файл:** `src/shared/lib/auth/permission-guard.tsx`

Ці компоненти дозволяють декларативно контролювати видимість UI.

-   `<Can permission="delete_contact"> <Button /> </Can>`: Кнопка буде показана тільки користувачам з дозволом `delete_contact`.
-   `<RequireRole roles={['owner', 'admin']}> <AdminPanel /> </RequireRole>`: Компонент `AdminPanel` буде видимий тільки для власників та адміністраторів.
-   `<RequireFeature feature="analytics"> <AnalyticsDashboard /> </RequireFeature>`: Компонент буде видимий тільки на тарифах, що включають аналітику.
-   `<ShowWhenAuthenticated>` / `<ShowWhenGuest>`: Показують вміст залежно від статусу автентифікації.

---

## 5. Система Ролей та Дозволів (RBAC)

**Файл:** `src/shared/lib/auth/permissions.ts`

Цей файл є "джерелом правди" для всієї системи дозволів.

-   **`Permission` (тип):** Перелік усіх можливих дій в системі (`"create_contact"`, `"manage_billing"` тощо).
-   **`ROLE_PERMISSIONS` (матриця):** Об'єкт, що співвідносить кожну роль (`owner`, `admin`, `manager`, `user`, `guest`) з масивом дозволів, які ця роль має.
-   **Допоміжні функції:**
    -   `hasPermission(role, permission)`: Основна функція для перевірки.
    -   `isRoleSeniorTo(roleA, roleB)`: Перевірка ієрархії ролей.
    -   `getAssignableRoles(currentUserRole)`: Повертає список ролей, які може призначати поточний користувач.

---

## 6. Ключові аспекти безпеки

1.  **Захист від Open Redirect:** У файлі `/auth/callback/route.ts` використовується "білий список" `ALLOWED_REDIRECT_PATHS`. Після логіну користувач може бути перенаправлений тільки на ті адреси, які явно дозволені, що унеможливлює редірект на шкідливі зовнішні сайти.

2.  **Валідація сесії на сервері:** Використання `supabase.auth.getUser()` в `AuthProvider` є ключовим елементом безпеки. Це гарантує, що клієнтський додаток ніколи не приймає рішень на основі неперевірених даних.

3.  **Http-Only Cookies:** Бібліотека `@supabase/ssr` автоматично використовує захищені, `http-only` cookies для зберігання сесії. Це означає, що токени сесії недоступні для клієнтського JavaScript, що є надійним захистом від XSS-атак, спрямованих на крадіжку сесії.

4.  **Row-Level Security (RLS):** Вся логіка в додатку (хуки, компоненти-охоронці) є лише першим рівнем захисту для покращення досвіду користувача (UI/UX). Фінальним і абсолютним джерелом правди є політики RLS на рівні бази даних Supabase. Навіть якщо зловмисник зможе обійти логіку на клієнті, він не зможе отримати чи змінити дані, до яких у нього немає доступу згідно з RLS.
