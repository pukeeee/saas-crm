# Розділ 8: Модель Підписки та Білінгу

Монетизація продукту базується на моделі щомісячної або щорічної підписки (SaaS) з різними тарифними планами. Кількість доступних воркспейсів, а також ліміти на користувачів та дані залежать від обраного тарифу.

## 8.1. Тарифні Плани

Тарифні плани розроблені для задоволення потреб бізнесу на різних етапах його розвитку.

| План | Орієнтовна ціна (UAH/міс) | Воркспейси | Користувачі | Контакти | Сховище | Ключові особливості |
|---|---|---|---|---|---|---|
| **Free** | 0 | 1 | 2 | 100 | 500 MB | Базовий функціонал CRM для одного проекту. |
| **Starter** | 299 | 5 | 5 | 5,000 | 5 GB | Все з "Free", пріоритетна підтримка, до 5 воркспейси. |
| **Pro** | 799 | 20 | 20 | 50,000 | 50 GB | Все з "Starter", плюс розширена аналітика, автоматизація та доступ до API. |
| **Enterprise** | Індивідуально | Необмежено | Необмежено | Необмежено | Все з "Pro", плюс White-label, персональний менеджер. |

### Платні модулі (Add-ons)

Замість створення великої кількості тарифних планів, ми пропонуємо гнучку систему "à la carte", що дозволяє клієнтам на тарифі "Starter" і вище докуповувати додаткові модулі за окрему щомісячну плату. Це дозволяє не перевантажувати базові тарифи та надавати вузькоспеціалізований функціонал тим, хто його потребує.

**Приклади модулів:**
*   **Складський облік:** ~150 грн/міс
*   **Поглиблена автоматизація (Workflows):** ~200 грн/міс
*   **Розширена інтеграція з Email/SMS:** ~100 грн/міс + вартість повідомлень
*   **Доступ до відкритого API:** ~250 грн/міс

Технічно, доступ до модулів буде керуватися через поле в таблиці `subscriptions`, де зберігатиметься список придбаних модулів для кожної організації. Інтерфейс буде динамічно відображати або приховувати відповідний функціонал.

## 8.2. Інтеграція з Платіжними Системами

Для обробки платежів та керування підписками буде інтегровано зовнішній платіжний шлюз.

*   **Основний вибір:** **Paddle**. Цей сервіс виступає як "Merchant of Record", що означає, що він бере на себе всі турботи щодо податків (включаючи ПДВ для міжнародних клієнтів) та комплаєнсу.
*   **Альтернативи для України:** **Fondy**, **WayForPay** можуть бути інтегровані для зручності локальних клієнтів.

**Процес оплати:**
1.  Адміністратор в налаштуваннях обирає план та переходить на сторінку оплати (Checkout Page), надану платіжним шлюзом.
2.  Після успішної оплати платіжний шлюз надсилає на наш сервер **вебхук** (webhook) з інформацією про подію (`subscription_created`, `payment_succeeded` тощо).
3.  Наш бекенд обробляє вебхук, перевіряє його достовірність та оновлює статус підписки для відповідної організації в базі даних.

## 8.3. Керування Лімітами (Quota Management)

Система автоматично відстежує використання ресурсів для кожного робочого простору. Це реалізовано за допомогою гібридного підходу, що поєднує ефективність бази даних та гнучкість бізнес-логіки на рівні додатку.

### Технічна реалізація

1.  **Таблиця `workspace_quotas`:** Це центральна таблиця, де для кожної організації зберігаються як максимальні ліміти тарифу (`max_contacts`, `max_users`), так і поточне використання (`current_contacts`, `current_users`).

2.  **Рівень даних: Автоматичне оновлення лічильників (Тригери)**
    Для максимальної продуктивності підрахунок поточного використання ресурсів виконується на рівні бази даних. Спеціальні тригери (`update_workspace_usage`) автоматично збільшують або зменшують лічильники (`current_contacts`, `current_deals` тощо) при кожній операції `INSERT` або `DELETE` у відповідних таблицях. Це дозволяє уникнути повільних запитів `COUNT(*)` при кожній перевірці.

3.  **Рівень додатку: Перевірка квот перед створенням (Сервісний шар)**
    Уся бізнес-логіка перевірки лімітів інкапсульована в `quota.service.ts`. Перед створенням будь-якої нової сутності, що підлягає квотуванню, серверна дія (Server Action) **обов'язково** викликає метод `canCreateEntity` з цього сервісу.

    ```typescript
    // app/actions/contacts.ts (спрощений приклад)
    import { canCreateEntity } from "@/shared/lib/services/quota.service";
    import { createContactInDb } from "@/shared/lib/repositories/contact.repository";

    export async function createContact(data: ContactInput) {
      const workspaceId = await getCurrentWorkspaceId(); // Отримуємо ID воркспейсу
      
      // 1. Перевірка квоти через сервіс
      const canCreate = await canCreateEntity(workspaceId, "contacts");
      if (!canCreate) {
        return { success: false, error: "Досягнуто ліміт контактів для вашого тарифу." };
      }
      
      // 2. Якщо перевірка успішна, створюємо запис через репозиторій
      const contact = await createContactInDb(workspaceId, data);
      
      // Тригер в БД автоматично оновить лічильник current_contacts
      
      return { success: true, data: contact };
    }
    ```
    `canCreateEntity` всередині себе викликає `quota.repository.ts` для отримання актуальних даних з `workspace_quotas` і порівнює `current_` з `max_`.

4.  **Оновлення максимальних лімітів (RLS Політика)**
    Коли користувач змінює тарифний план (наприклад, через `billing.service.ts`), системі потрібно оновити максимальні ліміти (`max_contacts`, `max_users`) в таблиці `workspace_quotas`. Для цього створена спеціальна політика безпеки RLS, яка дозволяє **лише адміністраторам або власнику** організації виконувати операцію `UPDATE` над записами в цій таблиці. Це гарантує, що звичайний користувач не може змінити свої ліміти, а система білінгу може це робити безпечно.

## 8.4. Логіка Оновлення та Пониження Тарифу

*   **Оновлення (Upgrade):** Відбувається миттєво. Після успішної оплати нові, вищі ліміти та додатковий функціонал стають доступними одразу.

*   **Пониження (Downgrade):** Це складніший процес, що базується на принципі **"ніколи не видаляти дані автоматично"**. Якщо після переходу на нижчий тариф організація перевищує його ліміти (наприклад, має 7 користувачів при ліміті 5), система застосовує "м'які" обмеження:
    *   **Ліміт на дані (контакти, угоди):** Створення нових записів блокується. Користувач бачить повідомлення "Досягнуто ліміт записів для вашого тарифу. Щоб додати нові, видаліть старі або оновіть тариф". При цьому всі існуючі дані залишаються доступними для перегляду та редагування.
    *   **Ліміт на користувачів:** Система не блокує "зайвих" користувачів автоматично. Замість цього, адміністратор бачить попередження "У вашій команді 7 користувачів, що перевищує ліміт тарифу (5). Будь ласка, деактивуйте 2 користувачів". Можливість запрошувати нових членів команди блокується.
    *   Перед підтвердженням пониження тарифу система завжди показує чітке попередження про всі наслідки та обмеження.

## 8.5. Модель Даних для Білінгу

```sql
-- Таблиця для керування підписками організацій
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workspace_id UUID NOT NULL REFERENCES workspaces(id),
  tier TEXT NOT NULL, -- 'free', 'starter', 'pro'
  status TEXT NOT NULL DEFAULT 'active', -- 'active', 'past_due', 'cancelled', 'trialing'
  enabled_modules TEXT[] DEFAULT '{}', -- Масив активованих платних модулів, напр: ['inventory', 'api_access']
  
  -- Інформація про білінг
  billing_period TEXT, -- 'monthly', 'annual'. Може бути NULL, напр. для тарифу "Free"
  current_period_start TIMESTAMPTZ NOT NULL,
  current_period_end TIMESTAMPTZ NOT NULL,
  cancelled_at TIMESTAMPTZ,
  
  -- Інформація від платіжного провайдера
  payment_provider TEXT, -- 'paddle', 'fondy'
  external_subscription_id TEXT, -- ID підписки в зовнішній системі
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Таблиця для історії платежів
CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  subscription_id UUID NOT NULL REFERENCES subscriptions(id),
  workspace_id UUID NOT NULL REFERENCES workspaces(id),
  
  amount NUMERIC(10,2) NOT NULL,
  currency TEXT NOT NULL,
  status TEXT NOT NULL, -- 'pending', 'completed', 'failed', 'refunded'
  
  payment_provider TEXT NOT NULL,
  external_payment_id TEXT, -- ID платежу в зовнішній системі
  
  invoice_url TEXT, -- Посилання на інвойс/квитанцію
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);
```

## 8.6. План реалізації білінгу в MVP

Для MVP реалізація білінгу буде спрощеною, але закладе основи для повноцінної системи.

1.  **Вибір провайдера та налаштування:** Вибрати основного провайдера (напр., Paddle) та налаштувати в ньому продукти, що відповідають нашим тарифним планам.
2.  **Інтеграція Checkout:** Створити в інтерфейсі сторінку "Білінг", де адміністратор може обрати тариф. Кнопка "Оплатити" перенаправляє на сторінку оплати, згенеровану провайдером.
3.  **Створення обробника вебхуків:** Реалізувати захищений ендпоінт (`/api/webhooks/payment`) для прийому сповіщень від платіжної системи (про успішну оплату, скасування підписки тощо).
4.  **Оновлення статусу в БД:** Обробник вебхуків має оновлювати дані в таблицях `subscriptions` та `payments`.
5.  **Застосування логіки тарифів:** Система має перевіряти статус підписки та застосовувати відповідні ліміти (наприклад, блокувати створення нових контактів при перевищенні квоти).
6.  **Тестування:** Провести повне тестування циклу оплати в "пісочниці" (sandbox mode) платіжного провайдера.
